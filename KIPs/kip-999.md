---
kip: 999
title: BlobTx for Kaia
author: Ollie (@blukat29), Nasu (@tnasu), Shogo (@ulbqb)
discussions-to: TBU
status: Draft
type: Core
created: 2025-11-24
---

## Abstract

Introduce the Blob transaction type that represents the existence of data blobs, corresponding KZG commitments and proofs. this KIP follows the latest Ethereum Fusaka specs and will be included in Kaia's Osaka Hardfork. Therefore, [EIP-4844](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md) is the baseline, but also includes the [EIP-7516](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7516.md) BLOBBASEFEE opcode and [EIP-7594](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7594.md) cell proof format. The blob per block limit was lowered to fit in Kaia's short 1-second block time. Since the limit is low, the target gas mechanism was removed for simplicity.

## Motivation

Kaia wants to accomodate rollups for scalability and specialized features in L2 chains. Rollups typically needs to upload its summary data onto L1 which incurs a high data load. For instance, if an L2 submits a 128 KB blob every 10 second, the chain receives 33 GB a month and pays 33,000 KAIA. With this KIP, the L2 can post its data through [EIP-4844 compatible blob transactions to provide cost-effective and scalable](https://docs.arbitrum.io/how-arbitrum-works/inside-arbitrum-nitro) method. As the blockchain can be free from the burden of persisting the calldata, the chain can offer a lower pricing.

## Specification

### Parameter

**Type parameters**

| Parameter | Value | Note |
|-|-|-|
| `BLOB_TX_TYPE` | `0x03` | For Ethereum compatible RLP |
| `TxTypeEthereumBlob` | `0x7803` | For Kaia consensus RLP |
| `VERSIONED_HASH_VERSION_KZG` | `0x01` | Prefixed to `BlobVerionedHash` |
| `BlobSidecarVersion` | `0x01` | The wrapper_version of `BlobTxWithBlobs` |

**Blob size parameters**

| Parameter | Value | Note |
|-|-|-|
| `BYTES_PER_FIELD_ELEMENT` | 32 | (byte/elem) |
| `FIELD_ELEMENTS_PER_BLOB` | 4096 | (elem/blob) |
| `BYTES_PER_BLOB` | `BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB` = 131072 | 128 KB
| `GAS_PER_BLOB` | 131072 | (blobgas/blob). 1 blobgas/byte |
| `MAX_BLOB_GAS_PER_BLOCK` | 131072 | max 1 blob/block |
| `MIN_BASE_FEE_PER_BLOB_GAS` | 250000000000 | 250 gkei/blobgas |
| `BLOB_SIDECARS_RETENTION` | 1814400 blocks | 21 days |

**Cell proof parameters**

| Parameter | Value | Note |
|-|-|-|
| `FIELD_ELEMENTS_PER_EXT_BLOB` | `2 * FIELD_ELEMENTS_PER_BLOB` = 8192 | (elem/extblob) |
| `FIELD_ELEMENTS_PER_CELL` | 64 | (elem/cell) |
| `BYTES_PER_CELL` | `FIELD_ELEMENTS_PER_CELL * BYTES_PER_FIELD_ELEMENT` = 2048 | (byte/cell) |
| `CELLS_PER_EXT_BLOB` | `FIELD_ELEMENTS_PER_EXT_BLOB // FIELD_ELEMENTS_PER_CELL` = 128 | (cell/extblob) |

***Data types**

| Type | Definition |
|-|-|
| `Blob` | `[BYTES_PER_BLOB]byte` = `[131072]byte` |
| `Commitment` | `[48]byte` |
| `Proof` | `[48]byte` |
| `VersionedHash` | `[32]byte` = `0x01 + hash(commitment)[1:]` |
| `BlobTxWithBlobs` | `struct { }` |

TBU: diagram

### Blob transaction

The transaction fields are identical to the EIP-4844 definition.

```js
TransactionPayloadBody = [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes, y_parity, r, s]
```

All fields follow the same semantics as EIP-4844. Note that the `to` field cannot be `nil` and always be an address.

### Block header

The block header is extended with two new fields blob_gas_used and excess_blob_gas.

```py
class Header:
	parentHash:   hash
	rewardbase:   address
	root:         hash
	txHash:       hash
	receiptHash:  hash
	bloom:        bloom
	blockScore:   bigint
	number:       bigint
	gasUsed:      uint64
	time:         bigint
	timeFoS:      uint8
	extra:        bytes
	governance:   bytes
	vote:         bytes

	baseFee:      int   # since Magma, as per KIP-71

	randomReveal: bytes # since Randao, as per KIP-114
	mixHash:      bytes # since Randao, as per KIP-114

	blobGasUsed:   uint64 # since Osaka, as per KIP-xxx
	excessBlobGas: uint64 # since Osaka, as per KIP-xxx
```

### Networking

There are multiple network representations. BlobTx and BlobSidecar travel through the network of nodes in various forms.

```js
BlobTxRLP = 0x7803 || rlp(TransactionPayloadBody)
EthBlobTxRLP = 0x03 || rlp(TransactionPayloadBody)
BlobTxSidecar = rlp([sidecar_version, blobs, commitments, cellProofs])
BlobTxWithBlobs = rlp([TransactionPayloadBody, sidecar_version, blobs, commitments, proofs]
```

The Kaia chain internally processes the RLP encoding prefixed with `TxTypeEthereumBlob (0x7803)`. But for Ethereum compatibility, a Kaia node MAY return an RLP encoding prefixed with `BLOB_TX_TYPE (0x03)`.

**Sidecar format**

- Both BlobTxSidecar and BlobTxWithBlobs must include a `sidecar_version` field before the blobs field. The version field is also referred to as `BlobSidecarVersion` or `wrapper_version`.
- The sidecar version is `BlobSidecarVersion (0x01)` as per EIP-7594.
- There are `CELLS_PER_EXT_BLOB (128)` proofs (i.e. cell proofs) for each blob as per EIP-7594.

**Journey into the consensus node**

- An RPC endpoint node (usually EN, but PN and CN should do the same) MUST accept a `BlobTxWithBlobs` via its `eth_sendRawTransaction` and `kaia_sendRawTransaction` JSON-RPC API. The RPC endpoint node MUST propagate the `BlobTxWithBlobs`, including the `BlobTxSidecar`, to its peers.
- All nodes MUST verify `BlobTxWithBlobs` upon receiving it.

**Journey from the consensus node**

- When a block proposer decides to include a `BlobTx`, the proposer MUST confirm that the originating `BlobTxWithBlobs` is verified. Whenever you see a BlobTx in a mined (finalized) block, you are sure (because CNs confirmed and you trust CN) that there exists a sidecar corresponds to the `BlobTx.BlobVersionedHashes`. But blockchain doesnâ€™t store the sidecar itself.
- A block proposer SHOULD include the `BlobTxSidecar` in the block proposals so other CNs can verify the `BlobTx` against `BlobTxSidecar`.
- CNs SHOULD store the `BlobTxSidecar` in its filesystem. CNs MAY delete the `BlobTxSidecar` whose block number is older than `BLOB_SIDECARS_RETENTION` before the head block.
- CNs MUST NOT propagate the `BlobTxSidecar` to peers other than CN.
- Same as any other transactions, `BlobTxRLP` is propagated to other CN, PN, EN as part of the new block, and persisted to every node.

TBU: diagram

### Sidecar validation

Upon receiving a `BlobTxWithBlobs` via RPC or p2p, it is verified as follows.

1. The `BlobTxWithBlobs` format complies with EIP-7594.
  ```py
  tx, sidecar_version, blobs, commitments, proofs = blobTxWithBlobs
  assert sidecar_version == 1  # BlobSidecarVersion1
  assert len(tx.blobVersionedHashes) == len(blobs) == len(commitments)  # 1 commitment per blob
  assert len(blobs) * CELLS_PER_EXT_BLOB == len(proofs)  # 128 proofs per blob
  ```
2. The `BlobTxWithBlobs` contains the correct proofs
  ```py
  for i in range(len(tx.blobVersionedHashes)):
    assert CalcBlobHashV1(commitments[i]) == tx.blobVersionedHashes[i]
  assert VerifyCellProofs(blobs, commitments, cellProofs)
  ```

A `BlobTxWithBlobs` verification happens in these situations:
- Receive via `eth_sendRawTransaction` RPC
- Receive via [`TxMsg` p2p message](https://github.com/kaiachain/kaia/blob/v2.1.0/node/cn/protocol.go)
- Receive via [`IstanbulMsg` p2p message](https://github.com/kaiachain/kaia/blob/v2.1.0/consensus/istanbul/backend/handler.go)'s [Proposal payload](https://github.com/kaiachain/kaia/blob/v2.1.0/consensus/istanbul/types.go). Note that the `type Proposal interface` is instantiated as `*types.Block` which includes the transactions inside. Since a `BlobTxWithBlobs` is treated as a transaction, the Proposal should naturally include Sidecars.

### Block validation

A valid block must satisfy the following conditions. Note that the authenticity of the `tx.blobVersionedHashes` is not verified here because we assume that consensus nodes validated them against `BlobTxSidecar`.

Rules below are similar to the EIP-4844 'Execution layer validation' specification, except the `baseFeePerBlobGas` calculation.

1. `header.excessBlobGas` equals the value calculated from the parent header.
  ```py
  def calcExcessBlobGas(parent: Header) -> int:
    return max(0, parent.excessBlobGas + parent.blobGasUsed - TARGET_BLOB_GAS_PER_BLOCK)
  assert block.header.excessBlobGas == calcExcessBlobGas(block.parent.header)
  ```
2. For each BlobTx, the sender has enough balance to fund both execution gas and blob gas.
  ```py
  for tx in block.transactions:
    ...
    max_execution_fee = tx.gas * tx.maxFeePerGas
    max_blob_fee = len(tx.blobVersionedHashes) * GAS_PER_BLOB * tx.maxFeePerBlobGas
    assert signer(tx).balance >= max_execution_fee + max_blob_fee
    ...
  ```
3. For each BlobTx, there is at least one blob versioned hash with the correct version.
  ```py
  for tx in block.transactions:
    ...
    if tx.type == BLOB_TX_TYPE:
      assert len(tx.blobVersionedHashes) > 0
      for h in tx.blobVersionedHashes:
        assert h[0] = VERSIONED_HASH_VERSION_KZG
    ...
  ```
4. For each BlobTx, `tx.maxFeePerBlobGas` is at least the calculated `baseFeePerBlobGas`.
  ```py
  baseFeePerBlobGas = MIN_BASE_FEE_PER_BLOB_GAS
  for tx in block.transactions:
    if tx.type == BLOB_TX_TYPE:
      assert tx.maxFeePerBlobGas >= baseFeePerBlobGas
  ```
5. `header.blobGasUsed` is correctly calculated from the transactions and is below the limit.
  ```py
  blobGasUsed = 0
  for tx in block.transactions:
    if tx.type == BLOB_TX_TYPE:
      blobGasUsed += len(tx.blobVersionedHashes) * GAS_PER_BLOB
  assert block.header.blobGasUsed == blobGasUsed
  assert block.header.blobGasUsed <= MAX_BLOB_GAS_PER_BLOCK
  ```

### Opcodes

The `BLOBHASH (0x49)` opcode was introduced to the Kaia chain with the Cancun hardfork, but it has been returning a zero hash. Its behavior MUST change to take in one integer argument index and return `tx.blob_versioned_hashes[index]`. Its gas cost `3` stay the same.

The `BLOBBASEFEE (0x4a)` opcode was introduced to the Kaia chain with the Cancun hardfork, but it has been returning 0. Its behavior MUST change to return the blob base fee of the current block it is executing in. Its gas cost `2` MUST stay the same.

### Precompile

The `POINT_EVALUATION_PRECOMPILE (0x0a)` was introduced to the Kaia chain with the Cancun hardfork, and it does not change.

## API

#### eth_sendRawTransaction, kaia_sendRawTransaction

eth_sendRawTransaction and kaia_sendRawTransaction accepts a `BlobTxWithBlobs`. It MUST NOT accept `BlobTx` without the sidecar.

#### eth_getRawTransaction, kaia_getRawTransaction

eth_getRawTransaction returns the raw transaction RLP prefixed with `BLOB_TX_TYPE (0x03)`. kaia_getRawTransaction returns the raw transaction RLP prefixed with `TxTypeEthereumBlob (0x7803)`. Both APIs never return `BlobTxWithBlobs`.

#### eth_getBlock, eth_getTransaction, eth_getTransactionReceipt

These eth namespace APIs that return transaction fields MUST show the `maxFeePerBlobGas` and `blobVersionedHashes` fields, and its `type: "0x03"`.

#### kaia_getBlock, kaia_getTransaction, kaia_getTransactionReceipt

These kaia namespace APIs that return transaction fields MUST show the `maxFeePerBlobGas` and `blobVersionedHashes` fields, and its `typeInt: 30723`, and `type: "TxTypeEthereumBlob"`.

#### admin_getBlobSidecars

A new JSON-RPC API `admin_getBlobSidecars` returns the stored `BlobTxSidecars`, if available.

- Parameters:
  - `number` - integer or hexadecimal block number, or the string tags such as "pending", "latest".
  - `fullBlob` - If true, returns the full blob data. Otherwise, return up to the first 32 bytes of each blob. False by default.
- Returns:
  - An array of:
    - `blobSidecar` - A sidecar object
      - `version` - The `sidecar_version` in integer
      - `blobs` - An array of blobs in hex strings
      - `commitments` - An array of commitments in hex strings
      - `proofs` - An array of proofs in hex strings
    - `blockHash` - The hash of the block the blob is included
    - `blockNumber` - The number of the block the blob is included
    - `txHash` - The hash of the transaction the blob is included
    - `txIndex` - The index of the transaction the blob is included
- Example
  ```sh
  curl http://localhost:8551 -X POST -H "Content-Type: application/json" \
    --data '{"jsonrpc":"2.0", "id":1, "method":"admin_getBlobSidecars", "params":["0x1234",false]}' \
  ```
  ```json
  {
    "jsonrpc": "2.0",
    "id": 1,
    "result": [
      {
        "blobSidecar": {
          "version": 1,
          "blobs": [
            "0x61c47a49eb50be125fa6c05e1bc9f3eb1c7c555bddd93d8fc1be4d0bff6cae32"
          ],
          "commitments": [
            "0x90b049b9255bf13b96c226a1ec1a3dac0deac6533b55378c846e91839000ddc31a662afdfc489694add406846cfeefbf"
          ],
          "proofs": [
            "0xb4104a0b89b4a302c44c753560fae156107746edc98ce81c91d7045490eebee984bd9d96648bad6ff1454643ad00d2e1"
          ]
        },
        "blockHash": "0x1d67a5039edec9296a3f5935111da5b712df541905ff6ce9f3581d3bc7a1afbd",
        "blockNumber": "0xc0f6b6b",
        "txHash": "0xbb7376baf28c7a1698729ce91266ac82652281704fe217e0b5a5ef968e62b169",
        "txIndex": "0x1",
      }
    ]
  }
  ```

## Rationale


## References

- [EIP-4844 Shard Blob Transactions](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md)
- [EIP-7516 BLOBBASEFEE instruction](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7516.md)
- [EIP-7594 PeerDAS - Peer Data Availability Sampling](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7594.md)
- [EIP-7934 RLP Execution Block Size Limit](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7934.md)
- [Ethereum Deneb consensus specs](https://github.com/ethereum/consensus-specs/tree/master/specs/deneb)
- [Ethereum Fulu consensus specs](https://github.com/ethereum/consensus-specs/tree/master/specs/fulu)
- [Kaia BLOBHASH, BLOBBASEFEE, KZG precompile implementation](https://github.com/klaytn/klaytn/pull/2032)
- [Kaia RLP block size limit implemenation](https://github.com/kaiachain/kaia/pull/575)
- [AWS pricing calculator](https://calculator.aws/)
